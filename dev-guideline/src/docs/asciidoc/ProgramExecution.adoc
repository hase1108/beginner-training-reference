:toclevels: 5
:sectnums:

[ProgramExecution]
= プログラムの実行

[[ProgramExecution_Overview]]
== Overview
本節では、作成したプログラムがどのように実行されるか、どのような構造種類があるのかの解説を行う。

[[ProgramExecution_Code]]
== コード

ある特定のルールに従って記述され、コンピュータに解釈させる、もしくは何らかの動作を実行させることを目的として作成されたデータをコード(プログラムコード/ソースコード)と呼ぶ。  +
様々なソースコードの種類が存在するが、<<ComputerComponents.adoc#HowComputersWork_Component_Overview,前節>>で説明したように、最終的にCPUが解釈可能である二進数の形式である必要がある。  +
一方人間が二進数を直接解釈/記述するのは非常に難しい。そのため、通常は人間が解釈しやすい**高水準言語**を読み書きし、様々なツールを利用してネイティブコードに変換する方式をとる。 +
人間が解釈しやすい高水準言語に対して、ネイティブコードに近いものを**低水準言語**と呼ぶ。 +
以下に概要図を示す。  +

.プログラムの階層構造
[#programing_hierarchy]
image::ProgramExecution/ProgramHierarchy.png[プログラムの階層構造]

プログラムを実行する場合は、既にネイティブコードになっているexeファイルなどであれば、コマンドプロンプトやシェルを通じて実行を指示することができる。  +
またJavaScriptなどでは各Webブラウザがインタプリンタを内部に持っているため、ブラウザ上で動作させたりすることができる。  +

[[ProgramExecution_Code_Low-LevelLang]]
=== 低水準言語
前述したように、機械が解釈できる二進数で書かれたネイティブコード、またネイティブコードに近い形式であるアセンブリ言語などは低水準言語と呼ばれる。  +
実務的にはアセンブリ言語やネイティブコードを直接取り扱うことは少ない。  +
メモリやCPUのI/Oを直接制御可能であることが強みである。

[[ProgramExecution_Code_Low-LevelLang_Native]]
==== ネイティブコード
CPUなどに直接命令を指示できるような二進数もしくは理解しやすいように16進数で記述されたコードをネイティブコードもしくは機械語と呼ぶ。  +
ネイティブコードは基本的にCPUに対する命令の部分とデータ部分もしくは命令で操作される対象から成り立ち、命令の部分はCPUの種類によって仕様が異なるため種類の異なるCPUでは同じコードでも実行されることが異なる。  +
この命令の仕様を**命令セット**と呼び、命令のことを**オペコード**、オペコードによって操作される対象を**オペランド**と呼ぶ。  +
汎用のCPUの多くが採用しているx86-64系のネイティブコードの仕様は https://software.intel.com/en-us/articles/intel-sdm[intel] のwebページ上で公開されている。  +
前述したように、どのようなプログラミング言語でも最終的にはこのネイティブコードに変換される。  +

実際のexeファイルをバイナリエディタで開いた例を以下に示す。

.ネイティブコードの例
[#native_code]
image::ProgramExecution/NativeCode.png[ネイティブコードの例]

[[ProgramExecution_Code_Low-LevelLang_Assembly]]
==== アセンブリ言語
ネイティブコードはただの2進数か16進数の数値の羅列であるため、直接解釈、記述することは人間にとっては手間がかかる。  +
そのためネイティブコードを人間の理解しやすい形式に変換したものをアセンブリ言語と呼ぶ。  +
アセンブリはネイティブコードの命令セットに1対1で対応し、命令の内容が理解しやすいような単語に紐づけた部分、また後述するアセンブラに対する命令(疑似命令)やマクロに紐づく部分。そしてその操作の対象となるデータなどから成り立つ。  +
ネイティブコードの命令セットに対応する部分を**ニーモニック**と呼ぶ。  +
ニーモニックは例えば、`mov a, b` のような命令であれば**aの値をbに移す**という命令になる。この場合、`mov` がニーモニックであり、`a, b` がオペランドになる。  +
以下にGo言語で引数の二乗を計算するコードを https://godbolt.org/[Compiler Explorer]でアセンブリに変換したものを示す。

.アッセンブリの例
[#assembly_code]
image::ProgramExecution/Assembly.png[アセンブリの例]

[[ProgramExecution_Code_Low-LevelLang_Assembly_Assembler]]
===== アセンブラ
アセンブリ言語で記述されたコードを変換し、実行可能なネイティブコードを生成する機能をアセンブラと呼ぶ。  +
アセンブリ言語のソースに対して、何回走査して変換するかによって種類が分けられる。

[[ProgramExecution_Code_High-LevelLang]]
=== 高水準言語
ネイティブコードやアセンブリ言語など、人間に理解しづらくCPUやメモリを意識して記述するような低水準言語に対して、通常我々が使用する言語のように記述でき、ハードの事を意識しない傾向の言語を**高水準言語**と呼ぶ。  +
高水準言語は各言語のルールに従い、英単語などを組み合わせて記述される。  +
高水準言語で記述されたソースコードをCPUに直接解釈させることはできないため、何らかの方法でネイティブコードに変換する必要がある。  +
その方法として、ソースコードを実行前に事前に全て変換しておく**コンパイラ**、実行時に逐次変換する**インタプリタ**に分けられる。  +
実務上、アプリケーションとして作成するのはこのレイヤの言語のいずれかを用いることが多い。

[[ProgramExecution_Code_Language_Compiler]]
==== コンパイラ言語
高水準言語のうちC言語やGo言語など、ネイティブコードなど低水準言語への変換に**コンパイラ**と呼ばれるプログラムを用いて行うものを通称**コンパイラ言語**と呼ぶ。  +

高水準言語は高水準言語で書かれたコードそのものは実行することはできないため、プログラムを実行する前に事前にコンパイルを行う必要がある。  +
C言語ではれば``gcc``コマンドであり、Go言語であれば``go build``コマンドを実行することでコンパイルを行うことができる。  +
また、言語によっては直接ネイティブコードに変換するのではなく、アセンブリ言語に変換してネイティブコードに変換するのはアセンブラに任せるものや、何らかの中間言語に変換してさらに実行時にコンパイルする言語なども存在する。  +

コンパイル言語の特徴としては、インタプリタ言語と比較してプログラム実行時にネイティブコードへの翻訳は行われないため、比較的実行速度が早い。  +
一方プログラムに何らかのバグが存在する場合、一度コンパイルしないとわからないことなどが上げられる。

[[ProgramExecution_Code_Language_Interpreter]]
==== インタプリタ言語
高水準言語のうち、JavaScript言語やPython言語など、ネイティブコードなど低水準言語への変換に**インタプリタ**と呼ばれるプログラムを用いて行うものを通称**インタプリタ言語**と呼ぶ。  +

インタプリタ言語もコンパイラ言語と同様、高水準言語で書かれたコードそのものは実行できないため、ネイティブコードへの何らかの変換処理を行う必要がある。  +
この変換処理はインタプリタ言語の場合、基本的には書かれたコードをインタプリタを用いて一行ずつ逐次変換して実行する。  +

インタプリタ言語の特徴としては、プログラマ目線としてはコードを作成後に気軽に実行して動作を確認しやすいことが上げられる。  +
一方、実行環境にインタプリタが存在しなければならないこと、逐次コードを解釈しながら実行するため、コンパイラ言語と比べると比較的実行速度が遅いことが上げられる。

[[ProgramExecution_Code_Language_Others]]
==== その他
前述したように、高水準言語は実行方法によって大まかに二つに分類できるが、**Java**など一部の言語では**コンパイラ**と**インタプリンタ**の両方を用いてプログラムを実行する形式が存在する。  +
詳細については Java[リンク]の節で解説を行うが、JavaではJava言語で書かれた**javaファイル**をコンパイラで変換して中間コードである**classファイル**を生成する。  +
生成されたclassファイルをJVM上で実行する際に**実行時コンパイラ**と呼ばれる**JITコンパイラ**もしくはインタプリンタを通すことで実際のマシン上で動作するネイティブコードを生成する。  +
高水準言語からネイティブコードへの変換を複数段階で分けることで、他の言語と比較してプログラムを動作させる実マシンの仕様に左右されづらくなるなどのメリットがある。